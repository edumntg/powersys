from ..models.powersystem import PowerSystem
import numpy as np
from .solver import *

class OPF(Solver):

    def __init__(self, model: PowerSystem):
        super().__init__(model)

    def solve(self, disp = True):
        if not self.model:
            raise "No PowerSystem object declared"
        
        # Construct Ybus
        self.model.construct_ybus()

        # Construct Pyomo model
        self.construct_model_solver()

        # Now, solve
        self.state_dict()['solver'].solve(disp = disp)
        self.solved = True

        # Get variables
        _V = self.state_dict()['variables']['V']
        _theta = self.state_dict()['variables']['theta']
        _Pgen = self.state_dict()['variables']['Pgen']
        _Qgen = self.state_dict()['variables']['Qgen']        

        V = np.array([_V[bus.id][0] for bus in self.model.buses])
        theta = np.array([_theta[bus.id][0] for bus in self.model.buses])
        Pgen = np.array([_Pgen[gen.id][0] for gen in self.model.generators])
        Qgen = np.array([_Qgen[gen.id][0] for gen in self.model.generators])

        # Assign results
        self.assign_results(V, theta, Pgen, Qgen)

        # Load lagrange and kuhn-tucker multipliers
        # multipliers = np.loadtxt(model.path + '/apm_lam.txt')
        # self.multipliers = multipliers

    def construct_model_solver(self):

        super().construct_model_solver()

        # For OPF, set all Pgen_fixed and Qgen_fixed variables equal to zero
        for bus in self.model.buses:
            bus.Pgen_fixed = 0
            self.state_dict()['variables']['Pgen_fixed'][bus.id].VALUE = 0

        # Reactive power generated
        for bus in self.model.buses:
            bus.Qgen_fixed = 0
            self.state_dict()['variables']['Qgen_fixed'][bus.id].VALUE = 0

        # Create objective function
        self.state_dict()['solver'].Obj(self.__opf_objective())

        self.__construct_opf_contraints()
    
    def __opf_objective(self):
        state_dict = self.state_dict()
        total_cost = np.sum([gen.cost(state_dict['variables']['Pgen'][gen.id]) for gen in self.model.generators])

        return total_cost

    def __construct_opf_contraints(self):
        m = self.state_dict()['solver']
        # Bus voltage limits
        m.Equations([
            self.__opf_constr_bus_voltage_min(bus) for bus in self.model.buses
        ])
        m.Equations([
            self.__opf_constr_bus_voltage_max(bus) for bus in self.model.buses
        ])

        # Min active power generated by each generator
        m.Equations([
            self.__opf_constr_gen_Pmin(gen) for gen in self.model.generators
        ])

        # # Max active power generated by each generator
        m.Equations([
            self.__opf_constr_gen_Pmax(gen) for gen in self.model.generators
        ])

        # Min reactive power generated by each generator
        m.Equations([
            self.__opf_constr_gen_Qmin(gen) for gen in self.model.generators
        ])

        # # Max reactive power generated by each generator
        m.Equations([
            self.__opf_constr_gen_Qmax(gen) for gen in self.model.generators
        ])

        # Transmission lines limits
        m.Equations([
            self.__opf_constr_line_max_mva_fromto(line) for line in self.model.lines
        ])
        m.Equations([
            self.__opf_constr_line_max_mva_tofrom(line) for line in self.model.lines
        ])
    
    def __opf_constr_gen_Pmin(self, gen):
        return self.state_dict()['variables']['Pgen'][gen.id] >= self.state_dict()['variables']['lg'][gen.id]*gen.Pmin
    
    def __opf_constr_gen_Pmax(self, gen):
        return self.state_dict()['variables']['Pgen'][gen.id] <= self.state_dict()['variables']['lg'][gen.id]*gen.Pmax
    
    def __opf_constr_gen_Qmin(self, gen):
        return self.state_dict()['variables']['Qgen'][gen.id] >= self.state_dict()['variables']['lg'][gen.id]*gen.Qmin
    
    def __opf_constr_gen_Qmax(self, gen):
        return self.state_dict()['variables']['Qgen'][gen.id] <= self.state_dict()['variables']['lg'][gen.id]*gen.Qmax

    def __opf_constr_line_max_mva_fromto(self, line):
        # Get apparent power

        #return self.Pflow[line.from_bus, line.to_bus]**2 + self.Qflow[line.from_bus, line.to_bus]**2 <= line.mva**2
        Pflow = self.state_dict()['variables']['Pflow']
        Qflow = self.state_dict()['variables']['Qflow']
        return Pflow[line.from_bus, line.to_bus]**2 + Qflow[line.from_bus, line.to_bus]**2 <= line.mva**2
        #return self.state_dict()['variables']['Pflow'][line.from_bus, line.to_bus]**2 <= line.mva**2
    
    def __opf_constr_line_max_mva_tofrom(self, line):
        # Get apparent power

        #return self.Pflow[line.to_bus, line.from_bus]**2 + self.Qflow[line.to_bus, line.from_bus]**2 <= line.mva**2
        Pflow = self.state_dict()['variables']['Pflow']
        Qflow = self.state_dict()['variables']['Qflow']
        return Pflow[line.to_bus, line.from_bus]**2 + Qflow[line.to_bus, line.from_bus]**2 <= line.mva**2
        #return self.state_dict()['variables']['Pflow'][line.to_bus, line.from_bus]**2 <= line.mva**2

    def __opf_constr_bus_voltage_min(self, bus):
        return self.state_dict()['variables']['V'][bus.id] >= bus.Vmin
    
    def __opf_constr_bus_voltage_max(self, bus):
        return self.state_dict()['variables']['V'][bus.id] <= bus.Vmax
        